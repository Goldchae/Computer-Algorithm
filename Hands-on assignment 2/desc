# ğŸ“ 2-1: Longest Increasing Subsequence
## ha_2_1.py

- ì‹¤í–‰ ì‹œ
ì˜ˆì œ ë°°ì—´ : [10, 22, 9, 33, 21, 50, 41, 60]
ê²°ê³¼ê°’ : 
ê¸¸ì´ : 5
ìˆ˜ì—´ : [10, 22, 33, 50, 60]

- ì‚¬ìš©ì ì…ë ¥ìš©
```
import sys
input_array = list(map(int, sys.stdin.readline().split()))
LIS, LIS_length = lis(input_array)
print(LIS_length)
print(LIS)
```
input_arrayëŠ” ê³µë°±ìœ¼ë¡œ ê° ìš”ì†Œë¥¼ êµ¬ë¶„í•˜ì—¬ í•œ ì¤„ì— ì…ë ¥!
LISì˜ ê¸¸ì´ì™€ LIS ë°°ì—´ì´ ê°ê° í•œ ì¤„ì”© ë„ì–´ì„œ ì¶œë ¥!

---
# ğŸ“ 2-2: Find Minimum Number of Stamps Required
## ha_2_2.py

- ì‹¤í–‰ ì‹œ
ì˜ˆì œ ìš°í‘œ ë°°ì—´ : [1, 10, 21, 34, 70, 100, 350, 1225, 1500]
ì˜ˆì œ ê¸ˆì•¡ : 140
ê²°ê³¼ê°’ : í•„ìš” ìš°í‘œ ìˆ˜ : 2

- ì‚¬ìš©ì ì…ë ¥ìš©
```
import sys
input_stamps = list(map(int, sys.stdin.readline().split()))
postage_amount = int(sys.stdin.readline())
result = min_stamps(input_stamps, postage_amount)
print(result)
```
input_stampsëŠ” ê³µë°±ìœ¼ë¡œ ê° ìš”ì†Œë¥¼ êµ¬ë¶„í•˜ì—¬ í•œ ì¤„ì— ì…ë ¥!
postage_amountëŠ” ë‹¤ìŒ ì¤„ì— ìˆ˜ë¥¼ ì…ë ¥!
resultëŠ” ì¶œë ¥ í•„ìš” ìš°í‘œ ìˆ˜ ì¶œë ¥!

---

# ğŸ“ 2-3: All-Pair-Shortest-Path Problem
## ha_2_3.py
ì‹¤í–‰ ì‹œ
ì£¼ì–´ì§„ ì…ë ¥:
w = [    [0, 3, 'INF', 7],
    [8, 0, 2, 'INF'],
    [5, 'INF', 0, 1],
    [2, 'INF', 'INF', 0]
]
ë‘ ìµœë‹¨ ê²½ë¡œì˜ ê²°ê³¼:
ê²½ë¡œ (v1, v3): [1, 3]
ê²½ë¡œ (v0, v2): [0, 1, 2]


ì‚¬ìš©ì ì…ë ¥ìš©

import sys
input_matrix = []
for _ in range(4):  # 4x4 matrix
    row = list(map(lambda x: float('inf') if x == 'INF' else int(x), sys.stdin.readline().split()))
    input_matrix.append(row)

# Floyd-Warshall algorithm í˜¸ì¶œ
dist_matrix, next_vertex_matrix = floyd_warshall(input_matrix)

# ê²°ê³¼ ì¶œë ¥ (v1 to v3, v0 to v2)
print("Shortest path from v1 to v3:", reconstruct_path(1, 3, next_vertex_matrix))
print("Shortest path from v0 to v2:", reconstruct_path(0, 2, next_vertex_matrix))
input_matrixëŠ” ê° í–‰ì„ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•˜ì—¬ 4ì¤„ì— ì…ë ¥!
ê° ìš”ì†ŒëŠ” ì½¤ë§ˆ ì—†ì´ ê³µë°±ìœ¼ë¡œë§Œ êµ¬ë¶„í•˜ë©°, ë¬´í•œëŒ€ëŠ” 'INF'ë¡œ í‘œê¸°
ê° ê²½ë¡œì˜ ê²°ê³¼ëŠ” ì¬êµ¬ì„±ëœ ìµœë‹¨ ê²½ë¡œì˜ ì •ì ë“¤ì„ ì¶œë ¥
